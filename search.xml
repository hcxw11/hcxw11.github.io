<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次性能优化]]></title>
    <url>%2F2018%2F10%2F15%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[页面性能分析使用 chrome DevTools 的 Performance 工具分析页面性能，发现有大量的自动重排 (Reflow) 从上面的调用栈中可以看出，这里的产生问题的代码，来自Painter.js文件的 942 行，这个文件是属于 ECharts 库，点击Painter.js:942，会自动跳转到对应的代码处。 123456789101112131415161718_getSize: function (whIdx) &#123; var opts = this._opts; var wh = ['width', 'height'][whIdx]; var cwh = ['clientWidth', 'clientHeight'][whIdx]; var plt = ['paddingLeft', 'paddingTop'][whIdx]; var prb = ['paddingRight', 'paddingBottom'][whIdx]; if (opts[wh] != null &amp;&amp; opts[wh] !== 'auto') &#123; return parseFloat(opts[wh]); &#125; var root = this.root; // IE8 does not support getComputedStyle, but it use VML. var stl = document.defaultView.getComputedStyle(root); // 问题定位在这里 return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;&#125;, root[cwh]这个表达式中，直接从 dom 中获取 clientWidth 和 clientHeight，所以浏览器必须先要强制同步布局，确保之前的样式生效，但是其实图表的宽和高在组件挂载时，在父组件已经把宽和高计算好了，在这里是没有必要通过重排获取参数的。 参考：避免大型、复杂的布局和布局抖动 避免强制同步布局为了解决上面的问题，查找_getSize的调用栈 123456789if (!singleCanvas) &#123; this._width = this._getSize(0); this._height = this._getSize(1); var domRoot = this._domRoot = createRoot(this._width, this._height); root.appendChild(domRoot);&#125; else &#123; var width = root.width; var height = root.height;...&#125; 这里发现通过一个singleCanvas的变量来控制，找到singleCanvas的定义 1var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === 'CANVAS'; // In node ? 也就是说，我把初始化图表的 div 换成 canvas，singleCanvas就会变为 true 尝试了一下，看下效果 可以看到已经稍微好了一些，但是还有一些地方存在问题，接着按照上面的方法寻找 发现之前代码中存在直接从组件 ref 中获取 clientWidth 和 clientHeight，所以把代码改为从直接使用父组件中传入的 height 和 width。 12345678910111213141516171819// 初始化时，使用直接使用传入的值作为图表的width和height// const myChart = echarts.init(document.getElementById(this.id));const &#123; width, height &#125; = this.props;// 基于准备好的dom，初始化echarts实例const myChart = echarts.init(document.getElementById(this.id), null, &#123; width, height &#125;);...// 图表大小发生变化，// this.chart.resize()// 先清除图表，不然会发生抖动const &#123; width, height &#125; = this.props;this.chart.clear();this.chart.resize(&#123; height, width &#125;); 避免了布局的抖动之后，可以从图中看到自动重排 (Reflow)已经大大地减少了 拆分同步渲染继续看性能分析的结果，可以看到有一条很长的警告 这里的警告是 Handler took，说明因为一下子加载了多个图表，每个图表中都有执行init(初始化)和showData(显示数据)操作，并且可以看出这里的代码是同步执行的，为了避免堵塞线程，试试将上面的两个操作改为异步。 12345678setTimeout(() =&gt; &#123; // 基于准备好的dom，初始化echarts实例 const myChart = echarts.init(document.getElementById(this.id), null, &#123; width, height &#125;); this.chart = myChart; // 绘制图表 this.showData(data);&#125;, 0); 长条的堵塞已经没了 最后的错误是Recurring handler，来源自Timer Fired，看了代码后发现是因为图表的定制化需要，有一个图表的showData函数里面有大量的循环导致，暂时没有好的办法。]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js异步编程-Generator]]></title>
    <url>%2F2018%2F10%2F05%2Fjs%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-generator%2F</url>
    <content type="text"><![CDATA[js 异步编程-Generator回调表达异步时存在两个缺陷： 回调的异步不符合大脑的阅读顺序 回调时的信任问题，组合时的嵌套问题 Promise 把回调的控制反转反转回来，恢复了可信任性/可组合性。 这时还需要 Generator 来提供一个看似同步的异步流程控制。 关于 Generator这里简单地回顾一下 Generator 基本概念直接来看一个简单的 Generator 函数使用例子 123456789101112131415function* foo(x) &#123; var y = x * (yield); return y;&#125;var it = foo(6);// 启动foo(..)var res = it.next();console.log(res.value); // undefinedres = it.next(7);console.log(res.value); // 42 执行 Generator 函数，并不会直接执行，而是返回了一个遍历器对象（Iterator Object），调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。 可以看出与普通函数不同，Generator 函数可以暂停执行，所以在函数之前加了一个*以示区别。 yield遍历器对象的next方法的运行逻辑如下。 （1）遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。 （3）如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。 所以修改上面的代码 1234567891011121314151617function* foo(x) &#123; var y = x * (yield 'Hello'); // &lt;-- yield一个值! return y;&#125;var it = foo(6);var res = it.next();console.log(res.value); // "Hello"res = it.next(7);console.log(res.value); // 42// 第一个next()，并不传入任何东西 // "Hello"// 向等待的yield传入7 // 42 详细内容可以查看文档 为了熟悉语法，附带两个练习： 传值练习 1 传值练习 2 Generator 与异步改造异步操作12345678910111213141516171819202122function request(x, y) &#123; console.log('run foo'); setTimeout(() =&gt; &#123; console.log('calc'); it.next(x * y); &#125;, 2000);&#125;function* main() &#123; console.log('run main'); var text = yield request(7, 8); console.log('get value', text);&#125;var it = main();it.next();// 执行结果// run main// run foo// calc// get value 56 这段代码改造了一个异步的回调函数，使用yield来暂停后续的代码，得到一段看似同步的代码，从代码量来说代码好像变得更加复杂了，但实际上代码变得更好理解了：在使用request这个异步函数的时候，无需再去考虑函数中的异步细节，只需要知道执行这个异步函数可以得到一个结果，通过 Generator 把异步的细节抽象了。 错误捕获生成器 yield 暂停的特性意味着我们不仅能够从异步函数调用得到看似同步的返回值，还可以同步捕获来自这些异步函数调用的错误。 12345678910111213141516171819202122232425// 内部抛出错误foo() &#123; // 异步操作 ... if(err) &#123; // 向*main()抛出一个错误 it.throw(err); &#125; ...&#125;function* main() &#123; // 外部接收错误 try &#123; var text = yield foo( 11, 31 ); console.log('get value', text); &#125; catch (err) &#123; console.error( err ); &#125;&#125;var it = main();it.next(); Generator+Promise直接使用回调存在着一系列的问题，可以将上面的回调修改为使用 Promise。 12345678910111213141516171819202122232425function request(x, y) &#123; console.log('run request'); return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`calculation $&#123;x&#125; * $&#123;y&#125;`); resolve(x * y); &#125;, 2000); &#125;);&#125;function* main(x, y) &#123; console.log('run main'); var text = yield request(x, y); console.log('get value', text);&#125;var it = main(6, 7);var p = it.next().value; // 获得Promisep.then(text =&gt; it.next(text)); // 获取Promise返回的结果，再使用next将结果传入main中，继续运行main// 执行结果// run main// run request// calc// get value 42 支持 Promise 的 Runner如果有多个 Promise，就必须多次地在返回 Promise 的 then 中调用 next，使 Generator 继续执行。来制作一个自动运行 Generator 的执行器吧。 1234567891011121314151617181920212223242526272829303132333435363738function request(x, y) &#123; console.log('run request'); return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`calculation $&#123;x&#125; * $&#123;y&#125;`); resolve(x * y); &#125;, 2000); &#125;);&#125;// 增加多个Promisefunction* main(x, y) &#123; console.log('run main'); var x1 = yield request(x, 10); console.log('get x1', x1); var y1 = yield request(y, 10); console.log('get y1', y1); var text = yield request(x1, y1); console.log('get value', text);&#125;function run(gen) &#123; // 第一个参数是Generator函数，剩余参数用于Generator执行 var args = [].slice.call(arguments, 1); var it = gen.apply(this, args); (function next(value) &#123; const result = it.next(value); if (result.done) &#123; return result.value; &#125; else &#123; return result.value.then(next); // 同 result.value.then(text =&gt; next(text)); &#125; &#125;)();&#125;// 运行Generatorrun(main, 6, 7); 直接使用递归的方式重复上面说的所说的过程，继续改进，使用 Promise 返回执行器的运行情况，并处理运行中的错误。 改进 Runner123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172function request(x, y) &#123; console.log('run request'); return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`calculation $&#123;x&#125; * $&#123;y&#125;`); // reject(x * y); resolve(x * y); &#125;, 2000); &#125;);&#125;function* main(x, y) &#123; console.log('run main'); // throw '123'; var x1 = yield request(x, 10); console.log('get x1', x1); var y1 = yield request(y, 10); console.log('get y1', y1); var text = yield request(x1, y1); console.log('get value', text);&#125;function run(gen) &#123; var args = [].slice.call(arguments, 1); var it = gen.apply(this, args); return new Promise((resolve, reject) =&gt; &#123; onFulfilled(); // 异步操作正常执行 function onFulfilled(res) &#123; let ret; try &#123; ret = it.next(res); &#125; catch (e) &#123; return reject(e); &#125; next(ret); return null; &#125; // 当异步操作有报错时 function onRejected(err) &#123; let ret; try &#123; ret = it.throw(err); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; // 获得Generator中的下一个值 function next(result) &#123; if (result.done) &#123; // 一直到Generator运行结束后返回run的Promise return resolve(result.value); &#125; else &#123; return result.value.then(onFulfilled, onRejected); &#125; &#125; &#125;);&#125;const runPromise = run(main, 6, 7);runPromise .then(() =&gt; &#123; console.log('generator end'); &#125;) .catch(err =&gt; &#123; console.log('generator error ' + err); &#125;); 现在run返回了一个 Promise，可以获得 Generator 函数的运行状况，并且可以很好地捕获run中的错误： 如果request函数中发生了错误： then调用onRejected函数 通过it.throw向main中传递这个错误 如果main没有try...catch...对该错误进行处理，则向外部抛出错误 onRejected中的try...catch...捕获这个错误，调用run执行器返回 Promise 的reject 使用run执行器返回 Promise 的catch处理错误 如果main函数中发生了错误： 如果main没有try...catch...对该错误进行处理，则向外部抛出错误 onFulfilled中的try...catch...捕获这个错误，调用run执行器返回 Promise 的reject 使用run执行器返回 Promise 的catch处理错误 Generator 异步执行库co就是这样运行的。 async 和 await在 ES2017 标准引入了 async 函数，使得 Generator 的运行更加方便。实际上，它就是 Generator 函数的语法糖。 123456789101112131415161718192021function request(x, y) &#123; console.log('run request'); return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(`calculation $&#123;x&#125; * $&#123;y&#125;`); resolve(x * y); &#125;, 2000); &#125;);&#125;async function main(x, y) &#123; console.log('run main'); var x1 = await request(x, 10); console.log('get x1', x1); var y1 = await request(y, 10); console.log('get y1', y1); var text = await request(x1, y1); console.log('get value', text);&#125;main(6, 7); await可以自动地获取后面 Promise 返回的值，并执行next，让整个代码更加像同步。 同样的，如果request中发生了错误，可以使用try...catch...来捕获错误。 注：滥用 await 可能会导致性能问题，在异步的并发使用上应该使用Promise.all([...])处理。 yield 遍历器委托为了解决多个 Generator 之间的调用，使用yield * foo()语法，来委托 Generator 遍历器，可以理解为 Generator 的嵌套。 12345678910111213141516171819202122232425262728function* foo() &#123; console.log('*foo() starting'); yield 3; yield 4; console.log('*foo() finished');&#125;function* bar() &#123; yield 1; yield 2; yield* foo(); // yield委托! yield 5;&#125;var it = bar();var next = it.next();while (!next.done) &#123; console.log(next.value); next = it.next();&#125;// 执行结果// 1// 2// *foo() starting// 3// 4// *foo() finished// 5]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js异步编程-异步与回调]]></title>
    <url>%2F2018%2F07%2F29%2Fjs%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%2F</url>
    <content type="text"><![CDATA[js 异步编程-异步与回调​ 以下是看《你不知道的 JavaScript（中）》异步部分的感悟。 1. 关于异步​ 异步的概念由来已久，最早出现在操作系统的底层，在信号量、消息等地方有广泛的应用，但是在 JavaScript 中，异步的重要性尤为突出。如何准确地表达和控制程序在一段时间内按照预计的顺序执行，其实就是处理程序现在执行的部分和未来执行部分的关系。和使用多线程的语言不一样，使用单线程的 JavaScript 时总是使用异步操作，因为我们不能将现在执行的部分和未来执行部分中间的那段空闲时间用来等待（这样会导致整个 UI 锁死，无法进行任何交互）。 ​ ​ 伴随着 ajax（Asynchronous JavaScript and XML）席卷了 Web，前端充斥着大量的 ajax 和事件，这里有一个最基本的异步解决方案——回调。比如说，JavaScript 发出一个 ajax 请求，准备从服务器获取一些信息，可以在一个函数（回调）中设置好响应的代码，然后 JavaScript 会通知宿主环境（浏览器或者 node 等）：“现在我要暂停执行了，你一旦完成了网络请求，拿到了数据，就请调用这个函数。”然后，浏览器就会监听网络请求的响应，拿到数据之后，就会把回调函数插入到事件循环中，通过这种方式实现对回调的调度执行。 2. 回调​ 回调虽然是处理异步最常用的方法，但是也存在着很多缺陷。 2.1 顺序的大脑​ 在此停留一会，想一下如何描述以下的代码？ 12345// AsetTimeout(function() &#123; // C&#125;, 1000);// B ​ ​ 大多数人马上想到的内容类似于“执行 A，然后设定一个延时等待 1000 毫秒，事件到了之后马上执行 C，B 在 A 执行完毕之后执行”。 ​ 又或者是“执行 A，设定一个 1000 毫秒的延时，接着执行 B，然后定时器到时间后执行 C”。 ​ 尽管第二个版本在描述上面更加准确一些，但是正常顺序阅读代码的理解来说，却是第一个更加常见。这就凸显了大脑工作方式和代码执行方式的分歧，所以面对大量使用回调的代码时，我们不得不面对一个事实：代码变得难以理解、追踪、调试和维护。 ​ 我们需要一种更同步、更顺序、更阻塞的方式来表达异步。 2.2 嵌套回调与链式调用​ 让我们再来看一段伪代码 12345678doA(function() &#123; doC(); doD(function() &#123; doF(); &#125;); doE();&#125;);doB(); ​ ​ 这里的执行顺序是 A → B → C → D → E → F ，尽管可能可以准确地说出正确的执行顺序，但是因为是线性地阅读代码，所以我们的目光不得不随着函数上下地跳动，最后很不自然地得出了这个结果。而且在实际的使用场景中，代码会更加混乱。下面再让我们看一下链式调用： 123456doA() .doc() .doD() .doE() .doF();doB(); ​ 相对而言，可读性有了很大的提升。然而回调地狱不仅仅只是嵌套和缩进带来的阅读问题。如果上面回调的例子中，doC()这个函数产生了异常，这将导致后面的所有函数都无法正常执行，简单地在 doA 外包裹一层 try…catch…并不能捕获异步代码中的异常，为此我们需要针对 doC()加入一系列的错误处理代码。为了保持整个流程正常执行，不得不通过硬编码的方式，为每一个步骤加上错误处理代码，可以预见地这些代码无法复用，也别提什么代码的优雅了，这将给后面的维护和更新带来了巨大的难度，这才是回调地狱真正让人绝望的地方。 2.3 信任问题​ 让我们再看下回调使用的场景： 12345// Aajax( "..", function(..)&#123; // C&#125; );// B ​ 这里 A 和 B 部分的代码调用在我们自己的控制之下，而 C 中代码的调用则是在第三方的控制下（这里就是 ajax()函数），通常来说这种控制反转不会给程序带来问题，但是你并不能明确地保证在自己的代码环境下第三方的控制能在恰当的时候触发回调，这就导致了一系列的信任问题： 调用回调过早(在追踪之前); 调用回调过晚(或没有调用); 调用回调的次数太少或太多(就像你遇到过的问题!); 没有把所需的环境 / 参数成功传给你的回调函数; 吞掉可能出现的错误或异常; …… ​ 虽然可以使用一些特定的逻辑来解决这些信任问题，但是这无疑会造成代码更加难以维护，所以如果有内建的 API 能保证回调触发的准确性，将会给我们带来巨大的便利。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术栈]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%8A%80%E6%9C%AF%E6%A0%88%2F</url>
    <content type="text"><![CDATA[整理下 18 年 7 月为止使用过的技术栈 前端框架：vue react 全局状态容器：redux redux-saga vuex 路由：react-router vue-router 组件库：vux ant-design element mint-ui http 请求：axios fetch 图表工具： echarts highcharts g2(bizcharts) 地图：高德地图 百度地图 构建工具：webpack 包管理：npm yarn 脚手架： vue-cli dva-cli create-react-app ant-design-pro 动效库：ant-motion sprite.js 工具库：lodash 协同工作：git 编码规范：airbnb 语法校验：eslint 代码整理：eslint prettier node 框架：egg 数据库：mongodb 样式：less 其他：微信小游戏 react-native 部署：nginx]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ant design pro中的router使用]]></title>
    <url>%2F2018%2F07%2F11%2Fant-design-pro%E4%B8%AD%E7%9A%84router%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[react-routerdva 中虽然对 router 做了简单的封装，使用的是react-router这个库(react-router 文档) 下面是一个简单的 react-router 例子: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React from &quot;react&quot;;import &#123; BrowserRouter as Router, Route, Link &#125; from &quot;react-router-dom&quot;;const BasicExample = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/topics&quot;&gt;Topics&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;/topics&quot; component=&#123;Topics&#125; /&gt; &lt;/div&gt; &lt;/Router&gt;);const Home = () =&gt; ( &lt;div&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;/div&gt;);const About = () =&gt; ( &lt;div&gt; &lt;h2&gt;About&lt;/h2&gt; &lt;/div&gt;);const Topics = (&#123; match &#125;) =&gt; ( &lt;div&gt; &lt;h2&gt;Topics&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/rendering`&#125;&gt;Rendering with React&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/components`&#125;&gt;Components&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`$&#123;match.url&#125;/props-v-state`&#125;&gt;Props v. State&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;Route path=&#123;`$&#123;match.url&#125;/:topicId`&#125; component=&#123;Topic&#125; /&gt; &lt;Route exact path=&#123;match.url&#125; render=&#123;() =&gt; &lt;h3&gt;Please select a topic.&lt;/h3&gt;&#125; /&gt; &lt;/div&gt;);const Topic = (&#123; match &#125;) =&gt; ( &lt;div&gt; &lt;h3&gt;&#123;match.params.topicId&#125;&lt;/h3&gt; &lt;/div&gt;);export default BasicExample; 上面的例子中，可以看出一个路由节点主要使用Route，由 path 和组件(render 或 component)组成，导航栏则是使用Link，在 dva 也是类似如此，只是这里的Route和Link是根据配置动态生成的。 一个大致的流程定义在src/common/menu.js配置里导航栏，在src/common/router.js中配置了 path 和组件的关系，如下图： 外层路由配置在src/router.js中，配置了最外层的路由。这里主要是用于控制页面进入后台管理系统还是进入登陆页面。ant design pro 中生成框架时定义/user/*相关的路由是用于用户登录等操作，其他操作则是/*路径，从下面的配置中可以看出，如果匹配到了/user/*的路径会使用UserLayout组件，而其他页面会使用BasicLayout组件（AuthorizedRoute组件还用于判断权限，如果没有权限则跳转到/user/login，即登陆页面） 123456789101112131415&lt;Switch&gt; &lt;Route path=&quot;/user&quot; component=&#123;UserLayout&#125; /&gt; &lt;AuthorizedRoute path=&quot;/screen&quot; render=&#123;props =&gt; &lt;ScreenLayout &#123;...props&#125; /&gt;&#125; authority=&#123;[&apos;admin&apos;]&#125; redirectPath=&quot;/user/login&quot; /&gt; &lt;AuthorizedRoute path=&quot;/&quot; render=&#123;props =&gt; &lt;BasicLayout &#123;...props&#125; /&gt;&#125; authority=&#123;[&apos;admin&apos;]&#125; redirectPath=&quot;/user/login&quot; /&gt;&lt;/Switch&gt; 里层路由配置在src/layouts/BasicLayout.js中，配置了系统里层的路由配置。这里使用的是 antd 的Layout组件，对系统的导航栏，Header，Footer 做了全局的配置，以及对应路由内容的显示，一般结构如下： 这里的难点主要是如何根据上面配置动态生成导航栏和显示对应的内容。 内容显示 重定向到子页面 123&#123;redirectData.map(item =&gt; ( &lt;Redirect key=&#123;item.from&#125; exact from=&#123;item.from&#125; to=&#123;item.to&#125; /&gt;))&#125; 这段代码的作用是，比如系统管理的路径/system，下面第一个页面是账户管理路径/system/systemUser 1234567891011&#123; name: &apos;系统管理&apos;, icon: &apos;system&apos;, path: &apos;system&apos;, children: [&#123; name: &apos;账户管理&apos;, path: &apos;systemUser&apos;, &#125;, ... ]&#125; 如果访问/system，会自动重定向到/system/systemUser（因为/system是没有页面的） 显示当前的路由的页面 12345678910&#123;getRoutes(match.path, routerData).map(item =&gt; ( &lt;AuthorizedRoute key=&#123;item.key&#125; path=&#123;item.path&#125; component=&#123;item.component&#125; exact=&#123;item.exact&#125; authority=&#123;item.authority&#125; redirectPath=&quot;/exception/403&quot; /&gt;))&#125; 123456789101112131415161718// src/components/Authorized/AuthorizedRoute.js// 根据权限规则判断，如果有权限则正常访问页面，否则就访问redirectPath，即/exception/403&lt;Authorized authority=&#123;authority&#125; noMatch=&#123; &lt;Route &#123;...rest&#125; render=&#123;() =&gt; &lt;Redirect to=&#123;&#123; pathname: redirectPath &#125;&#125; /&gt;&#125; /&gt; &#125;&gt; &lt;Route &#123;...rest&#125; render=&#123;props =&gt; (Component ? &lt;Component &#123;...props&#125; /&gt; : render(props)) &#125; /&gt;&lt;/Authorized&gt; 这里就会通过Route组件，将 Layout 中的 Content 区域渲染为对应的内容。 默认路由，这里定义如果访问/这个路径，重定向到哪个路径 1&lt;Redirect exact from=&quot;/&quot; to=&#123;bashRedirect&#125; /&gt; 路由 NoFound，这里定义如果找不到对应的地址，访问的页面，即 404 页面 1&lt;Route render=&#123;NotFound&#125; /&gt; 导航栏pro 生成的时候提供了导航栏组件SiderMenu，但是因为我们需要自定义的导航栏的需求，这里是使用自己写的导航栏 1234567// src/layouts/BasicLayout.js// 传入当前的权限数据，导航栏数据和当前的路由&lt;LeftSiderMenu currentPermission=&#123;currentPermission&#125; menuData=&#123;getMenuData()&#125; location=&#123;location&#125;/&gt; 123456789101112131415161718192021// src/components/LeftSiderMenu// 首先根据传入的权限数据对导航栏数据进行筛选，然后通过Link生成导航栏，点击就跳转到对应的路由&lt;div className=&#123;styles.menuContainer&#125;&gt; &lt;ul className=&#123;styles.siderMenuUl&#125;&gt; &#123; subMenuList &amp;&amp; subMenuList.children &amp;&amp; subMenuList.children.map(item =&gt; ( this.isMenuAuthorized(item) &amp;&amp; ( &lt;Link key=&#123;item.path&#125; to=&#123;`/$&#123;item.path&#125;`&#125; replace&gt; &lt;li className=&#123;`$&#123;parentMenu&#125;/$&#123;subMenu&#125;` === item.path ? styles.active : &apos;&apos;&#125;&gt; &lt;div className=&#123;styles.itemBorder&#125; /&gt; &lt;div className=&#123;styles.itemIcon&#125; /&gt; &lt;div className=&#123;styles.itemContent&#125;&gt; &lt;span&gt;&#123;item.name&#125;&lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;/Link&gt; ) )) &#125; &lt;/ul&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>react</tag>
        <tag>ant design pro</tag>
        <tag>dva</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dva中的connect注解使用]]></title>
    <url>%2F2018%2F07%2F09%2Fdva%E4%B8%AD%E7%9A%84connect%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[效果首先看下效果，比如在 LoginPage 组件上面加了如下注解 1234567@connect((&#123; login, loading &#125;) =&gt; (&#123; login, submitting: loading.effects[&apos;login/login&apos;],&#125;))export default class LoginPage extends Component &#123; ...&#125; react-redux 从下图中可以看到，注解会自动在 LoginPage 组件外面包裹一层 Connect 组件，这个组件把 redux 状态树中我们需要的值传入 LoginPage 组件的 props 中 说明以下是 dva 中 connect 注解的定义（简单说明，详细 API） 123456789/** * Connects a React component to Dva. */export function connect( mapStateToProps?: Function, mapDispatchToProps?: Function, mergeProps?: Function, options?: Object): Function; 对照我们上面的定义，传入了一个 mapStateToProps 的函数 1234567891011121314(&#123; login, loading &#125;) =&gt; (&#123; login, submitting: loading.effects[&apos;login/login&apos;],&#125;)// 等于以下代码function (state) &#123; var login = state.login; var loading = state.loading; return &#123; login: login, submitting: loading.effects[&apos;login/login&apos;], &#125;;&#125; 这个函数的作用就是对 redux 中的 state 加工，然后把这里声明的 login 传入到子组件的 Props 中（这里使用了 es6 的解构和箭头函数） 在 dva 中的一个开发流程 在 src/modals 中增加 redux 配置文件，namespace 不能和其他文件重复，配置里面的写法来自redux-saga。比如说我这里叫做 testModal.js，namespace 也是 testModal。 123456789101112131415161718// import &#123; xxx &#125; from &apos;../services/xxx&apos;;// src/modals/testModal.jsexport default &#123; namespace: &quot;testModal&quot;, state: &#123;&#125;, effects: &#123; *fetch(&#123; payload &#125;, &#123; call, put &#125;) &#123; ... &#125;, &#125;, reducers: &#123; save(state, action) &#123; return &#123; ...state, &#125;; &#125;, &#125;,&#125;; 在 src/common/menu.js 中增加一个目录配置，这里的配置会在导航栏中体现，比如如下配置会在导航栏中显示测试，点击后会访问/testPath 这个页面。 12345678const menuData = [ &#123; name: &apos;测试&apos;, icon: &apos;remote&apos;, path: &apos;testPath&apos;, &#125;, ...] 在 src/router.js 中增加路径和组件的关系配置，这里会动态加载第一步中的配置文件，dynamicWrapper 中，第二个参数为配置文件的文件名(不是 namespace)，第三个参数是路径对应的组件 12345678910111213141516171819202122232425262728293031const routerConfig = &#123; &apos;/testPath&apos;: &#123; component: dynamicWrapper(app, [&apos;testModal&apos;], () =&gt; import(&apos;../routes/TestComponent&apos;)), &#125;, ...&#125;// wrapper of dynamicconst dynamicWrapper = (app, models, component) =&gt; &#123; ... // () =&gt; import(&apos;module&apos;) return dynamic(&#123; app, models: () =&gt; models.filter(model =&gt; modelNotExisted(app, model)).map(m =&gt; import(`../models/$&#123;m&#125;.js`)), // add routerData prop component: () =&gt; &#123; if (!routerDataCache) &#123; routerDataCache = getRouterData(app); &#125; return component().then(raw =&gt; &#123; const Component = raw.default || raw; return props =&gt; createElement(Component, &#123; ...props, routerData: routerDataCache, &#125;); &#125;); &#125;, &#125;);&#125;; 编写 TestComponent 中的对应内容即可。 @connect 注解还会传入 dispatch（用于发送 action 和路由跳转）和 history、location、match、routerData 等路由信息。 几个注意点： 如果 dynamicWrapper 中没有加载对应的配置文件，直接在组件中使用@connect 会无效。 如果组件的外层已经被 Connect 组件包裹，可以直接使用@connect，不再需要使用 dynamicWrapper 加载配置（比如上面 TestComponent 中的子组件就可以直接使用@connect），但是范围要在父组件声明范文内（比如上面的例子只能使用 testModal 相关的数据） namespace 如果重复会出现一些很莫名其妙的问题，比如已经发送 action 但是却不执行。 更多参考资料：dvaAPI dva.js 知识导图]]></content>
      <tags>
        <tag>react</tag>
        <tag>ant design pro</tag>
        <tag>dva</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目综合态势v1.0大屏总结]]></title>
    <url>%2F2018%2F06%2F22%2F%E7%BB%BC%E5%90%88%E6%80%81%E5%8A%BFv1.0%E5%A4%A7%E5%B1%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[用时两个星期做的大屏，还是觉得上一个大屏好看一些。 总体结构 关于不同分辨率适配 使用作为 vh 和 vw 长度单位，并设置 max 和 min 值，防止页面过度变形。 根据 Dashboard 组件的高度动态计算每个图表的高度，防止图表出现重叠 Dashboard 中监听 resize 事件，实时地获取显示区域的 height 在 LeftBoard 和 RightBoard 中，依据传入的 height 和 count 参数计算每个图表区域（附带标题 ）的高度。因为长度使用了 vh vw 作为单位，所以需要使用 ref 和 getComputedStyle()转化为 px 计算。 在 withTitle 中，计算去标题后的图表大小 定时器控制 定时器放在 model 里面生成、销毁(定时器放在子组件中，耦合度低但是开销大；放在父组件中，耦合度高开销大) 使用 saga 的 race 方法(参考链接)，判断 delay(延迟)和取消任务哪个先到来。如果在一个延时周期内，外部没有触发 endTimer 的 action，则执行对应的操作，然后开始下一个周期；如果外部触发了 endTimer，此时 cancel 有值，循环结果，即定时器关闭。 1234567891011121314151617181920*interval(&#123; payload &#125;, &#123; race, take &#125;) &#123; // 延时时长和操作 const &#123; time, callback &#125; = payload; let finished = false; while (!finished) &#123; ... // 执行对应的操作 callback(); ... const &#123; cancel &#125; = yield race(&#123; delay: delay(time), cancel: take(&apos;endTimer&apos;), &#125;); if (cancel) &#123; finished = true; &#125; &#125;&#125;, 地图设备点在 mapUtils 中封装了一个创建点的方法，具体的显示在 content 中传入 html，另外在 marker 中保存点信息，在需要获取点信息的地方，通过marker.getExtData()获取 12345678910111213141516171819 /** * 增加一个点 * @param &#123;object&#125; point 点信息 * @param &#123;string&#125; showType 显示模式(project、group) * @param &#123;object&#125; options 点的其他参数 */drawOnePoint(point, showType, options = &#123;&#125;) &#123; const marker = new AMap.Marker(&#123; position: point.coordinate, // 显示的内容 content: getMarkerContent(point, showType), offset: new AMap.Pixel(-12, -12), zIndex: 2000, // animation: &apos;AMAP_ANIMATION_BOUNCE&apos;, ...options, &#125;); marker.setExtData(&#123; ...point &#125;); return marker;&#125;, 弹窗高德地图上的弹窗 api 是直接操作 dom 节点，插入 html 字符串，这种方式在简单的页面上比较方便，一旦页面有多个，并且需要动态加载数据之后会一下子变得很麻烦，所以这里使用 react-dom 来显示弹窗页面。 首先创建窗体，此时窗体内容为&lt;div id=&#39;xx&#39;&gt;&lt;/div&gt; 12345678910111213141516 /** * 构建自定义信息窗体 * @param &#123;object&#125; param 带有id属性的点信息 */createInfoWindow(&#123; id &#125;) &#123; const info = document.createElement(&apos;div&apos;); info.id = id; const infoWindow = new AMap.InfoWindow(&#123; isCustom: true, // 使用自定义窗体 content: info, offset: new AMap.Pixel(16, -45), autoMove: true, closeWhenClickMap: true, &#125;); return infoWindow;&#125;, 绑定设备点和窗口的关系 123456789101112131415161718192021222324252627282930/** * 绑定点和窗口 * @param &#123;AMap.Marker&#125; marker 地图上的点 * @param &#123;AMap.InfoWindow&#125; myWindow 地图上的窗口 * @param &#123;object&#125; PointWindow 用于渲染到地图窗口中的组件 */bindingMarkerWindow(marker, myWindow, PointWindow) &#123; const deviceInfo = marker.getExtData(); // 鼠标点击marker弹出自定义的信息窗体 AMap.event.addListener(marker, &apos;click&apos;, () =&gt; &#123; // 在点的位置打开窗口 myWindow.open(marker.getMap(), marker.getPosition()); &#125;); // 打开窗口时渲染组件 AMap.event.addListener(myWindow, &apos;open&apos;, e =&gt; &#123; // console.log(e, &apos;before&apos;, node, ); ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;PointWindow deviceId=&#123;deviceInfo.id&#125; /&gt; &lt;/Provider&gt;, e.target.getContent() ); &#125;); // 关闭窗口时，从dom中删除组件 AMap.event.addListener(myWindow, &apos;close&apos;, () =&gt; &#123; ReactDOM.unmountComponentAtNode(document.getElementById(deviceInfo.id)); &#125;);&#125;, 注：在渲染组件的时候，需要再外面包一层&lt;Provider store={store}&gt;...&lt;/Provider&gt;，将外面全局 redux 的 store 传入，不然&lt;PointWindow /&gt;中的@connect()将不能正常使用。react 渲染结果如下 图表使用 bizcharts 图表组件，图表的所有颜色定义等属性放在constant.js文件中，图表组件放在components/Charts中。 自定义形状柱状图使用圆角矩形需要自己通过 canvas 绘制，在components/Charts/g2.js`中添加新的形状，具体的使用参考bizcharts-shape 文档。 1234567891011121314151617181920// 自定义 shape, 水平方向柱状图圆角矩形Shape.registerShape(&apos;interval&apos;, &apos;borderRadiusH&apos;, &#123; draw(cfg, container) &#123; const &#123; points &#125; = cfg; const parsePoints = this.parsePoints(points); // 将 0 - 1 转化为画布坐标 let width = (parsePoints[2].x - parsePoints[1].x) * 0.6; width = width &gt; MAX_WIDTH ? MAX_WIDTH : width; const attrs = &#123; x: (parsePoints[2].x + parsePoints[1].x - width) / 2, // 矩形起始点为左下角 y: parsePoints[1].y, width, height: parsePoints[0].y - parsePoints[1].y, fill: cfg.color, radius: width / 2, &#125;; return container.addShape(&apos;rect&apos;, &#123; attrs, &#125;); &#125;,&#125;); 使用时在 shape 中使用之前注册形状即可 1&lt;Geom type=&quot;interval&quot; shape=&quot;borderRadiusH&quot; position=&quot;x*y&quot; color=&#123;color&#125; /&gt; 自定义图例 加上 useHtml 代表使用 html 生成图例(默认为 canvas) containerTpl 控制图例的整体显示，itemTpl 控制图例中的每一项显示，推荐加上 g2 的相关 class 进行微调。 如果不需要 html 修改结构，也可以通过 css 覆盖原有的 class 属性。 12345678910111213141516171819202122&lt;Legend position=&quot;top&quot; useHtml containerTpl=&#123;` &lt;div class=&quot;g2-legend topLegend&quot;&gt; &lt;h4 class=&quot;g2-legend-title&quot;&gt;&lt;/h4&gt; &lt;ul class=&quot;g2-legend-list&quot; style=&quot;list-style-type:none;margin:0;padding:0;&quot;&gt;&lt;/ul&gt; &lt;/div&gt; `&#125; itemTpl=&#123;(value, itemColor, checked, index) =&gt; &#123; return `&lt;tr class=&quot;g2-legend-list-item item-$&#123;index&#125; $&#123;checked ? &apos;checked&apos; : &apos;unChecked&apos;&#125;&quot; data-value=&quot;$&#123;value&#125;&quot; data-color=$&#123;color[value]&#125; &gt; &lt;td &gt; &lt;i class=&quot;g2-legend-marker&quot; style=&quot;width:10px;height:10px;display:inline-block;margin-right:10px;background-color:$&#123; color[value] &#125;;&quot;&gt;&lt;/i&gt; &lt;span class=&quot;g2-legend-text title&quot;&gt;$&#123;value&#125;&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt;`; &#125;&#125;/&gt; 图表混合面积图和折线图混合，是一份数据同时画两个图表，每个图表中设置一个数据为透明，这样两个图表叠加起来，就看起来是一个面积图案加一个折线图案。 颜色渐变通过设置图表颜色为l(90) 0:#4DE8E9 1:#408ca8e6来显示渐变渐变色文档]]></content>
      <tags>
        <tag>react</tag>
        <tag>项目总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ant design pro中的权限控制]]></title>
    <url>%2F2018%2F06%2F10%2Fant-design-pro%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[因为后端使用 shiro 控制权限， 用户登录的时候返回的权限信息类似于 1['test/view', 'test/add', 'test/edit']; 仔细看了下 ant design pro 的权限控制组件后发现，可以很好地结合使用 1. mock 登录返回数据123456789101112if (password === '123' &amp;&amp; userName === 'wxc') &#123; res.send(&#123; status: 'ok', type, currentAuthority: [ 'test/view', // 页面浏览权限 'test/add', // 页面添加按钮权限 'test/edit', // 编辑按钮权限 ], &#125;); return;&#125; 2. 修改 antd pro 的权限组件因为框架已经自带了权限组件，但是这里的权限组件是通过&#39;admin&#39;，&#39;user&#39;这种字符串判断，而我们是登录后返回一个数组，所以要稍微修改下里面的权限判断逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// src/components/Authorized/CheckPermissions.js/** * 通用权限检查方法 * Common check permissions method * @param &#123; 权限判定 Permission judgment type string |array | Promise | Function &#125; authority * @param &#123; 你的权限 Your permission description type:string&#125; currentAuthorityString * @param &#123; 通过的组件 Passing components &#125; target * @param &#123; 未通过的组件 no pass components &#125; Exception */const checkPermissions = (authority, currentAuthorityString, target, Exception) =&gt; &#123; // 没有判定权限.默认查看所有,开发的时候可以使用 // Retirement authority, return target // 当前获取的权限处理成数组 const currentAuthority = currentAuthorityString.split(','); if (!authority) &#123; return target; &#125; // 数组处理 if (Array.isArray(authority)) &#123; let flag = false; authority.some(au =&gt; &#123; if (currentAuthority.indexOf(au) !== -1) &#123; flag = true; return true; &#125; else &#123; return false; &#125; &#125;); if (flag) &#123; return target; &#125; return Exception; &#125; // string 处理 if (typeof authority === 'string') &#123; if (currentAuthority.indexOf(authority) !== -1) &#123; return target; &#125; return Exception; &#125; // promise和function ... throw new Error('unsupported parameters');&#125;; 修改完毕之后就可以正常使用权限组件了 3. 记录用户权限登录获取到接口返回的权限信息后，通过工具类中封装好的setAuthority方法在 localStorage 中保存权限信息 1234import &#123; setAuthority &#125; from '../utils/authority';... setAuthority(payload.currentAuthority);... 效果如下： 保存权限信息完毕之后，还需要通过reloadAuthorized方法来刷新权限组件 1234import &#123; reloadAuthorized &#125; from '../utils/Authorized';... reloadAuthorized();... 下面就可以正常使用 ant design pro 的权限控制功能了 4. 权限控制方式控制菜单显示这种方式下，路由导向也会做相应的控制，推荐使用这种方式 1234567// src/common/menu.js&#123; name: '权限测试页面', icon: 'user', path: 'test', authority: 'test/view', &#125;, 控制路由导向12345// src/common/router.js'/test': &#123; component: dynamicWrapper(app, [], () =&gt; import('../routes/Test')), authority: 'test/view',&#125;, 或 12345678import Authorized from '../../utils/Authorized';const &#123; Secured &#125; = Authorized;@Secured('test/view')export default class Test extends Component &#123; ...&#125; 页面内组件控制12345678910111213141516import Authorized from '../../utils/Authorized';export default class Test extends Component &#123; ... render() &#123; const noMatch = &lt;div&gt;没有权限&lt;/div&gt;; return ( &lt;div&gt; 权限测试页面 &lt;Authorized authority="test/add" noMatch=&#123;noMatch&#125;&gt; &lt;button&gt;添加&lt;/button&gt; &lt;/Authorized&gt; &lt;/div&gt; ); &#125;&#125; 效果如下：]]></content>
      <tags>
        <tag>react</tag>
        <tag>ant design pro</tag>
        <tag>dva</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插件安利]]></title>
    <url>%2F2018%2F06%2F08%2Fvscode%E6%8F%92%E4%BB%B6%E5%AE%89%E5%88%A9%2F</url>
    <content type="text"><![CDATA[1. Bracket Pair Colorizer括号高亮 2. Atom One Dark Theme字体配色 3. Code Spell Checker单词拼写校验 4. Import Costimport 消耗计算 5. Less IntelliSenseless 文件代码补全 6. Material Icon Theme文件图标 7. Open in Browser在 html 文件右键菜单上增加在浏览器上打开 8. React-Native/React/Redux snippets for es6/es7常用代码片段 9. SVG Viewer浏览 svg 文件，转 svg 文件为 png 文件 10. Auto Close Tag自动闭合标签 11. Auto Rename Tag闭合标签一起修改名字]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[egg中的路由和中间件]]></title>
    <url>%2F2018%2F05%2F15%2Fegg%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[18 年 5 月内部分享时用的 node ppt 整理 Router 路由作用 Router 主要用来描述请求 URL 和具体承担执行动作的 Controller 的对应关系， 框架约定了 app/router.js 文件用于统一所有路由规则。 通过统一的配置，我们可以避免路由规则逻辑散落在多个地方，从而出现未知的冲突，集中在一起我们可以更方便的来查看全局的路由规则。 如何定义 Routerapp/router.js 里面定义 URL 路由规则 12345// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get(&apos;/user/:id&apos;, controller.user.info);&#125;; app/controller 目录下面实现 Controller 123456789// app/controller/user.jsclass UserController extends Controller &#123; async info() &#123; const &#123; ctx &#125; = this; ctx.body = &#123; name: `hello $&#123;ctx.params.id&#125;`, &#125;; &#125;&#125; 当用户执行 GET /user/123，app/controller/user.js 这个里面的 info 方法就会执行。 Router 详细定义说明1router.verb(&apos;router-name&apos;, &apos;path-match&apos;, middleware1, ..., middlewareN, app.controller.action); 路由完整定义主要包括 5 个主要部分(有颜色部分为必填): verb - 用户触发动作，支持 get，post 等所有 HTTP 方法。 router - name 给路由设定一个别名，可以通过 Helper 提供的辅助函数 pathFor 和 urlFor 来生成 URL。 path-match - 路由 URL 路径。 middleware1 - 在 Router 里面可以配置多个 Middleware。 controller - 指定路由映射到的具体的 controller 上，controller 可以有两种写法： app.controller.user.fetch - 直接指定一个具体的 controller &#39;user.fetch&#39; - 可以简写为字符串形式 注意事项 在 Router 定义中， 可以支持多个 Middleware 串联执行 Controller 必须定义在 app/controller 目录中。 一个文件里面也可以包含多个 Controller 定义，在定义路由的时候，可以通过 ${fileName}.${functionName} 的方式指定对应的 Controller。 Controller 支持子目录，在定义路由的时候，可以通过 ${directoryName}.${fileName}.${functionName}的方式制定对应的 Controller。 RESTful 风格的 URL 定义 如果想通过 RESTful 的方式来定义路由，使用 app.resources(&#39;routerName&#39;, &#39;pathMatch&#39;, controller) 快速在一个路径上生成 CRUD 路由结构。 12345// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.resources(&apos;posts&apos;, controller.posts);&#125;; 上面代码就在 /posts 路径上部署了一组 CRUD 路径结构，对应的 Controller 为 app/controller/posts.js 接下来， 你只需要在 posts.js 里面实现对应的函数就可以了。 | Method | Path | Route Name | Controller.Action || —— | ————— | ———- | —————————– || GET | /posts | posts | app.controllers.posts.index || GET | /posts/new | new_post | app.controllers.posts.new || GET | /posts/:id | post | app.controllers.posts.show || GET | /posts/:id/edit | edit_post | app.controllers.posts.edit || POST | /posts | posts | app.controllers.posts.create || PUT | /posts/:id | post | app.controllers.posts.update || DELETE | /posts/:id | post | app.controllers.posts.destroy | 获取 Query String 参数 使用ctx.query 1234567891011// app/router.jsmodule.exports = app =&gt; &#123; app.router.get(&apos;/params&apos;, controller.params.queryString);&#125;;// app/controller/params.jsexports.queryString = async ctx =&gt; &#123; ctx.body = `search: $&#123;ctx.query.name&#125;`;&#125;;// curl http://127.0.0.1:7001/params?name=egg 获取 URL 中的参数 使用ctx.params 1234567891011// app/router.jsmodule.exports = app =&gt; &#123; app.router.get(&apos;/params/:id/:name&apos;, controller.params.urlParams);&#125;;// app/controller/params.jsexports.urlParams = async ctx =&gt; &#123; ctx.body = `user: $&#123;ctx.params.id&#125;, $&#123;ctx.params.name&#125;`;&#125;;// curl http://127.0.0.1:7001/params/123/xiaoming 注： 路由里面也支持定义正则，可以更加灵活的获取参数 表单内容获取 使用ctx.request.body 123456789// app/router.jsmodule.exports = app =&gt; &#123; app.router.post(&apos;/params&apos;, app.controller.params.bodyParam);&#125;;// app/controller/params.jsexports.bodyParam = async ctx =&gt; &#123; ctx.body = `body: $&#123;JSON.stringify(ctx.request.body)&#125;`;&#125;; 内部重定向123456789101112// app/router.jsmodule.exports = app =&gt; &#123; app.router.get(&apos;index&apos;, &apos;/home/index&apos;, app.controller.home.index); app.router.redirect(&apos;/&apos;, &apos;/home/index&apos;, 302);&#125;;// app/controller/home.jsexports.index = async ctx =&gt; &#123; ctx.body = &apos;hello controller&apos;;&#125;;// curl -L http://localhost:7001 外部重定向 使用ctx.redirect() 12345678910// app/router.jsmodule.exports = app =&gt; &#123; app.router.get(&apos;/baidu&apos;, controller.params.baidu);&#125;;// app/controller/params.jsexports.baidu = async ctx =&gt; &#123; const q = ctx.query.q || &apos;nodejs&apos;; ctx.redirect(`https://www.baidu.com/s?wd=$&#123;q&#125;`);&#125;; 路由整理 将相关的模块整合放在同一个文件中，在app/router.js中统一调用 12345678910// app/router.jsmodule.exports = app =&gt; &#123; require(&apos;./router/params&apos;)(app);&#125;;// app/router/params.jsmodule.exports = app =&gt; &#123; app.router.get(&apos;/params&apos;, controller.params.queryString); app.router.get(&apos;/params/:id/:name&apos;, controller.params.urlParams);&#125;; 中间件背景环境 Egg 2.x 基于 Koa 2.x，框架底层以及所有内置插件都使用async function编写 Koa 的洋葱圈模型 Koa 中间件的执行顺序 egg 中间件 Egg 是基于 Koa 实现的，所以 Egg 的中间件形式和 Koa 的中间件形式是一样的，都是基于洋葱圈模型。每次我们编写一个中间件，就相当于在洋葱外面包了一层。 1234567891011121314// /app/middleware/text.jsmodule.exports = () =&gt; &#123; return async function text(ctx, next) &#123; const query = ctx.query; console.log(query); await next(); const body = ctx.body; console.log(JSON.stringify(query), body); &#125;;&#125;;// /config/config.default.jsconfig.middleware = [ &apos;text&apos; ]; egg 约定一个中间件是一个放置在app/middleware目录下的单独文件，它需要 exports 一个普通的 function 中间件参数配置中间件 exports 的 function，接受两个参数： options: 中间件的配置项，框架会将 app.config[middlewareName] 传递进来。 app: 当前应用 Application 的实例。 框架和插件中使用中间件 框架和插件不支持在 config.default.js 中匹配 middleware，需要通过以下方式： 123456789101112131415// app.jsmodule.exports = app =&gt; &#123; // 在中间件最前面统计请求时间 app.config.coreMiddleware.unshift(&apos;report&apos;);&#125;;// app/middleware/report.jsmodule.exports = () =&gt; &#123; return async function (ctx, next) &#123; const startTime = Date.now(); await next(); // 上报请求时间 reportTime(Date.now() - startTime); &#125;&#125;; router 中使用中间件 以上两种方式配置的中间件是全局的，会处理每一次请求。 如果你只想针对单个路由生效，可以直接在 app/router.js 中实例化和挂载 12345678910// /app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; // 直接传递参数 // const logMiddleware = app.middleware.log(&#123; a: &apos; log in router &apos; &#125;); // 使用config中的参数 const logMiddleware = app.middleware.log(app.config.log); router.get(&apos;/text&apos;, logMiddleware, controller.home.index);&#125;; 框架默认中间件 除了应用层加载中间件之外，框架自身和其他的插件也会加载许多中间件。所有的这些自带中间件的配置项都通过在配置中修改中间件同名配置项进行修改，例如框架自带的中间件中有一个 bodyParser 中间件（框架的加载器会将文件名中的各种分隔符都修改成驼峰形式的变量名），我们想要修改 bodyParser 的配置，只需要在 config/config.default.js 中编写 12345module.exports = &#123; bodyParser: &#123; jsonLimit: &apos;10mb&apos;, &#125;,&#125;; 注意：框架和插件加载的中间件会在应用层配置的中间件之前，框架默认中间件不能被应用层中间件覆盖，如果应用层有自定义同名中间件，在启动时会报错。 通用配置无论是应用层加载的中间件还是框架自带中间件，都支持几个通用的配置项(config/config.default.js)： enable：控制中间件是否开启。 match：设置只有符合某些规则的请求才会经过这个中间件。 ignore：设置符合某些规则的请求不经过这个中间件。 enable 如果我们的应用并不需要默认的 bodyParser 中间件来进行请求体的解析，此时我们可以通过配置 enable 为 false 来关闭它 12345module.exports = &#123; bodyParser: &#123; enable: false, &#125;,&#125;; match 和 ignore match 和 ignore 支持的参数都一样，只是作用完全相反，match 和 ignore 不允许同时配置。 如果我们想让 gzip 只针对 /static 前缀开头的 url 请求开启，我们可以配置 match 选项 12345module.exports = &#123; gzip: &#123; match: &apos;/static&apos;, &#125;,&#125;; match 和 ignore 支持多种类型的配置方式 字符串：当参数为字符串类型时，配置的是一个 url 的路径前缀，所有以配置的字符串作为前缀的 url 都会匹配上。 正则：当参数为正则时，直接匹配满足正则验证的 url 的路径。 函数：当参数为一个函数时，会将请求上下文传递给这个函数，最终取函数返回的结果（ture/false）来判断是否匹配。 123456789module.exports = &#123; gzip: &#123; match(ctx) &#123; // 只有 ios 设备才开启 const reg = /iphone|ipad|ipod/i; return reg.test(ctx.get(&apos;user-agent&apos;)); &#125;, &#125;,&#125;; 谢谢！]]></content>
      <tags>
        <tag>egg</tag>
        <tag>node</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步I/O分享]]></title>
    <url>%2F2018%2F01%2F14%2F%E5%BC%82%E6%AD%A5I-O%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[node.js-异步 I/O18 年 1 月份内部分享时用的 node ppt 整理 背景环境 异步最早出现在操作系统的底层，通过信号量、消息等方式有广泛的应用 伴随着 AJAX(Asynchronous JavaScript and XML)席卷了 Web，前端编程中充斥着各种 AJAX 和事件，这些都是典型的异步应用场景。在 Node 出现前，前端工程师是最习惯异步编程的程序员 在大多数高级编程语言中，习惯采用同步的方式编写应用——异步不适合进行程序设计 Node 是首个将异步作为主要的编程方式和设计理念的，伴随着异步 I/O 的还有事件驱动和单线程，一同构成 Node 的基调 为什么要异步 I/O 用户体验 资源分配 用户体验 如果网页需要获取一个网络资源，通过同步的方式获取，那么在获取资源资源的这段时间里 UI 将停顿，用户体验会很差。所以在资源下载期间，需要通过异步消除 UI 阻塞现象 并发请求资源，后端快速响应资源 系统资源分配多线程和单线程多线程并行完成 在多核 CPU 上面能够有效提升 CPU 的利用率 创建线程和执行期线程上下文切换的开销大常常面临锁、状态同步等问题 单线程串行完成 符合顺序思考的思维方式，易于表达 性能较低，一个略慢的任务都会导致后续执行代码被阻塞 两种模型对比 Node 的选择 使用单线程，远离多线程死锁、状态同步等问题，减少资源使用 利用异步 IO，让主线程远离阻塞，提高 CPU 使用效率 ​ 异步 IO 的实现 事件循环 观察者 请求对象 执行回调 Node 的特点 异步 I/O 事件与回调函数 单线程 跨平台 Node 通过事件驱动的方式处理请求，无须为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低，这使得服务器能够有条不紊地处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响。 Node 的问题 异步编程容易造成逻辑混乱，使用异步的方式控制任务顺序执行（Promise，async/await） 单线程的弱点（Web Workers，Nnigx 反向代理，负载均衡，开多个进程，绑定多个端口） 无法利用多核 CPU 错误会引起整个应用退出，应用的健壮性存在问题 大量计算占用 CPU 导致无法继续调用异步 IO Node 的应用场景 擅长处理 I/O 密集型任务，不擅长处理 CPU 密集型任务。 高并发业务 长链接 非 I/O 的异步 API 定时器 process.nextTick() setImmediate() 定时器setTimeout()和 setInterval()和浏览器中的 API 是一致的，分别用于单次和多次定时执行任务。 调用 setTimeout()或者 setInterval()创建的定时器对象会被插入到定时器观察者中，每次事件循环，定时器观察者都会取出定时器对象，检查是否超时，如果超时，就形成一个事件，调用对应的回调函数 定时器是非精确的（在容忍范围内），如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。 process.nextTick()立即异步执行一个任务 123setTimeout(function () &#123; // TODO&#125;, 0) setTimeout 较为浪费性能，在 node 环境下使用 process.nextTick()更高效 123process.nextTick(function () &#123; // TODO&#125;) process.nextTick()只会将回调函数放入队列中，在下一轮事件循环时取出执行，时间复杂度为 O(1)，而定时器由于需要检索寻找符合条件的任务返回，时间复杂度为 O(lg(n)) setImmediate()setImmediate()和 process.nextTick()方法类似，都是立即异步执行一个任务。 区别: 优先级 process.nextTick()用数组实现用 1000 的长度限制，setImmediate()用链表实现没有长度限制 在 setImmediate 中，如果一个立即异步任务是被一个正在执行的回调排入队列的，则该立即异步任务直到下一次事件循环才会被触发。 谢谢！ 什么是 Event Loop? 使用异步 I/O 大大提高应用程序的性能 C++ in Node.js 业务场景及开发实现 - crcrcry 的文章 - 知乎 node.js API 文档 process.nextTick(callback[, …args]) node.js API 文档 setImmediate(callback[, …args])]]></content>
      <tags>
        <tag>分享</tag>
        <tag>node ppt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORY Editor入门指南]]></title>
    <url>%2F2017%2F12%2F19%2Fory%20editor%2F</url>
    <content type="text"><![CDATA[因为工作需要借鉴了此编辑器，发现官方的教程有些过时了，而且有些地方有错误，所以特地翻译成了中文，并做了一点修正。 原 git 项目地址：https://github.com/ory/editor [TOC] 介绍欢迎来到 ORY Editor 指南。请注意，ORY Editor 需要大量的 ReactJS 知识，构建工具如 webpack 以及 ES6。 示范眼见为实，所以让我们从一个演示开始！ 这是示例程序，可以自己尝试一下！ 区别现有的开源内容编辑解决方案有三个缺陷之一： 不得不使用许多措施来防御 XSS 威胁。 使用编辑器的作者必须学习一些语法，如 markdown，才能编写内容。这些基于文本的解决方案通常无法指定布局，并且不能制作复杂的结构（如表格布局）。 有前途的开源项目可能会遇到被维护者遗弃的问题，因为它可能只是别人用来打发空闲时间的项目。 所以好的解决方案必须符合以下原则： 状态是规范化的 JSON 对象，不涉及 HTML，用来防止 XSS。 这是一个可视化编辑器，不需要编程经验或特殊培训。 它由一家公司创建，减少了被遗弃的可能性。 基于可重复使用的 React 组件，它为开发人员、作者和设计人员提供了新的工作方式，能更轻松更好地创建更丰富的体验。 适配移动端。 出于这些原则，作者制作了 ORY Editor。 运行原理ORY Editor 主要是一个创建和修改布局的工具，核心是Cell和Row。布局与bootstrap 栅格布局非常相似。 编辑器的最外层是Editable，一个Editable的示例性结构可能如下： 12345678910111. Editable+-1. Container cell +-1. Row | +-1. Cell (text) | |-2. Cell (parallax background image) | +-1. Row | +-1. Cell (image) | |-2. Cell (image) |-2. Row | +-1. Cell (image) | |-2. Cell (image) 有四种不同的数据类型： Editable（结构树中的1.） - Editable是Cell和Row的容器。一个页面里可以有多个Editable，并且可以将Cell从一个Editable区域拖拽到另一个Editable区域。 ​ Container cell（结构树中的1.1） - Container cell是一个没有插件的Cell，它为Editable提供结构。这些Container cell在需要时自动生成，并在不再需要时自动删除。 ​ Content cell（结构树中的 1.1.1，1.2.1…） - Content cell格始终是树的一个叶子节点（它没有子节点），节点由内容插件定义（可由您编写或从 npm 下载）。内容插件通常是富文本，视频，音频，图片等等。 ​ Layout cell - Layout cell包含、嵌套Cell和Row（容器，内容，布局）的列表。Layout cell的作用是，它给子节点一个布局样式（比如布局内所有文字都是红色）。布局是由布局插件定义的。Layout cell必须至少有一个子节点，否则Layout cell将被自动删除。 带图片插件的Content cell 具有可切换背景图像插件的Layout cell 网格系统很好地集成到了 ORY Editor 中。它负责一切的拖拽逻辑、调整大小、焦点检测等等。作为开发人员，主要使用内容插件和布局插件来扩展功能，只需编写接收onChange，readOnly，state（编辑器产生）的简单 ReactJS 组件，完整的数据模型交给 ORY Editor。在后面的章节中学习插件如何正确工作，插件的外观以及如何编写自己的插件。 使用指南核心ORY Editor 的核心是ory-editor-core。它包含创建和修改布局的逻辑，并负责处理插件。 入门ORY Editor 使用 Redux store 来管理内部状态。 123import Editor from 'ory-editor-core';const editor = new Editor(); 当创建一个新的Editor实例，Redux store 也被创建。因此，在应用程序生命周期中必须仅实例化一次Editor（单例模式）。 1234import Editor from 'ory-editor-core';const editor = new Editor();const editor2 = new Editor(); // 不要这样做！. 添加插件现在我们知道如何创建一个空的Editor。现在让我们加一些插件。我们将使用ORY Editor 资源库提供的插件。我们称这些插件为“ory plugins”，因为它们是由官方编写和维护的。 让我们为初学者做一个图片插件。图片插件是一个简单的内容插件，允许您通过图片 URL 来添加图像，目前不支持上传图片。 ory图像插件 要安装图片插件，我们使用 NPM： npm install ory-editor-plugins-image。接下来，我们需要将它添加到我们的编辑器实例中： 12345678910import Editor from 'ory-editor-core';import image from 'ory-editor-plugins-image';import 'ory-editor-plugins-image/lib/index.css';const editor = new Editor(&#123; plugins: &#123; content: [image], &#125;,&#125;); 让我们从头到尾看下这段代码。首先，我们导入图片插件和它所需的 CSS： 12import image from 'ory-editor-plugins-image';import 'ory-editor-plugins-image/lib/index.css'; 我们假设你正在运行带有能够导入 CSS 的插件。 接下来，我们创建编辑器实例，并通过构造函数传递图像内容插件。 12345const editor = new Editor(&#123; plugins: &#123; content: [image], &#125;,&#125;); 当然也可以选择在运行时（也就是在创建编辑器实例之后）添加/设置/删除布局和内容插件，如下所示。使用这些方法将强制重新渲染编辑器。 123editor.addContentPlugin(image);editor.removeContentPlugin(image);editor.setContentPlugins([image]); 渲染接下来，我们显然想渲染编辑器。从核心软件包（ory-editor-core）导出一个名为Editable的 ReactJs 组件。假设我们的 HTML 是这样： 1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;div id="editable-1"&gt;&lt;/div&gt; &lt;div id="controls"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 在这种情况下，JavaScript 代码如下所示： 123456789101112131415import React from 'react';import ReactDOM from 'react-dom';import Editor, &#123; Editable &#125; from 'ory-editor-core';import image from 'ory-editor-plugins-image';import 'ory-editor-plugins-image/lib/index.css';const editor = new Editor(&#123; plugins: &#123; content: [image], &#125;,&#125;);ReactDOM.render(&lt;Editable editor=&#123;editor&#125; /&gt;, document.getElementById('editable-1')); 我们只需要渲染Editable组件并传递editor实例。但这里什么都不会发生，这是因为没有可供呈现的内容。 创建一个空的状态通过核心导出一个名为createEmptyState的方法创建一个空 state。结果是一个 JSON 对象，其中包含一个唯一的 ID。 123456789import &#123; createEmptyState &#125; from 'ory-editor-core';const editable = createEmptyState();console.log(editable.id);//&#123;// "id": "258ef48a-9668-43c5-a771-d279f014a3a4",// "cells": [ ]//&#125; 把这个添加到上面的代码中，我们得到： 123456789101112131415161718192021import React from 'react';import ReactDOM from 'react-dom';import Editor, &#123; Editable, createEmptyState &#125; from 'ory-editor-core';import image from 'ory-editor-plugins-image';import 'ory-editor-plugins-image/lib/index.css';const editable = createEmptyState();const editor = new Editor(&#123; plugins: &#123; content: [image], &#125;, editables: [editable],&#125;);ReactDOM.render( &lt;Editable editor=&#123;editor&#125; id=&#123;editable.id&#125; /&gt;, document.getElementById('editable-1')); 请注意，必需添加id={editable.id}到&lt;Editable&gt;，Editable会通过 id 与 editable 中的 id 对比来判断数据是否属于该Editable，我们也可以自定义 id，只要数据中的 id 也对上： 123456789101112ReactDOM.render( &lt;div&gt; &lt;div className="left"&gt; &lt;Editable editor=&#123;editor&#125; id="1" /&gt; &lt;/div&gt; &lt;div className="right"&gt; &lt;Editable editor=&#123;editor&#125; id="2" /&gt; &lt;/div&gt; &lt;/div&gt;, document.getElementById('editable-1')); 保存和加载现在你已经知道了如何渲染一个编辑器并且用一个空的 state 来填充它，让我们来看看如何保存数据和加载数据。 可以使用onChange属性来捕获&lt;Editable&gt;的更改。onChange的参数是一个新的 editable，包含了整个Editable里所有的 state 的序列化值。 12345678910ReactDOM.render( &lt;Editable editor=&#123;editor&#125; id="1" onChange=&#123;editable =&gt; &#123; console.log(editable); &#125;&#125; /&gt;, document.getElementById('editable-1')); 它仅包含原始值（string, number, array, map），并且它可以序列化为 JSON。 比方说，你有一个叫saveToBackend的函数用来存储数据到数据库。你可以在 onChange 调用这个方法： 12345678910ReactDOM.render( &lt;Editable editor=&#123;editor&#125; id="1" onChange=&#123;editable =&gt; &#123; saveToBackend(editable); &#125;&#125; /&gt;, document.getElementById('editable-1')); 要加载内容，只需将其传递给构造函数 1234567891011121314151617const editable = loadFromBackend() // just an exampleconst editor = new Editor(&#123; plugins: &#123; content: [image] &#125;, editables: [editable],&#125;)or use the `trigger` API.​```jsx// const editor = new Editor( ...const editable = loadFromBackend() // 只是一个例子，用来取序列化的state数据editor.editable.update(editable) // 如果尚未存在，则添加内容，如果已在store存在，则更新 教程ReactJS 示例在本节中，我们将创建一个使用 ORY Editor 的简单 react app。请确保您的系统上安装了node.js 目前，ORY Editor 只能通过 npm 使用，而且在 ReactJS 环境下效果最好。 ReactJS首先创建一个 ReactJS 应用程序。 12$ npm i -g create-react-app$ create-react-app . 使用 npm 安装 ory-editor： 1$ npm i --save ory-editor 接下来，打开文件src / components / App.js添加 ORY Editor： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React from 'react';// 加载编辑器核心import Editor, &#123; Editable, createEmptyState &#125; from 'ory-editor-core';import 'ory-editor-core/lib/index.css'; // we also want to load the stylesheets// 加载UI组件（悬浮在左侧的添加编辑按钮等），你也可以使用自己的实现的，这里使用的是官方的组件import &#123; Trash, DisplayModeToggle, Toolbar &#125; from 'ory-editor-ui';import 'ory-editor-ui/lib/index.css';// 加载插件:import slate from 'ory-editor-plugins-slate'; // 富文本内容插件import 'ory-editor-plugins-slate/lib/index.css'; // Stylesheets for the rich text area pluginimport parallax from 'ory-editor-plugins-parallax-background'; // 视差背景布局插件import 'ory-editor-plugins-parallax-background/lib/index.css'; // Stylesheets for parallax background imagesrequire('react-tap-event-plugin')(); // react-tap-event-plugin is required by material-ui which is used by ory-editor-ui so we need to call it here// 定义哪些插件是我们要用的，这里我们只使用了slate和parallax两个插件，所以只加载这两个const plugins = &#123; content: [slate()], // 定义内容插件 layout: [parallax(&#123; defaultPlugin: slate() &#125;)], // 定义布局插件&#125;;// 创建空的editable，表示编辑器中内容为空const content = createEmptyState();// 实例化编辑器const editor = new Editor(&#123; plugins, // 通过editables传递数据，可以有多个content，表示多个数据源，Editor会使用id来判断是否渲染 editables: [content],&#125;);class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;/* 编辑器内容 */&#125; &lt;Editable editor=&#123;editor&#125; id=&#123;content.id&#125; /&gt; &#123;/* UI组件 */&#125; &lt;Trash editor=&#123;editor&#125; /&gt; &lt;DisplayModeToggle editor=&#123;editor&#125; /&gt; &lt;Toolbar editor=&#123;editor&#125; /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 就是这样，恭喜！你现在应该看到这样的东西： 这里的 Text 和 Parallax Background 就是刚刚在 plugins 中添加的内容插件（slate）和布局插件（parallax） 写插件编写一个内容插件你可以很容易地编写自己的插件。插件有两个部分，一个是插件的定义，另一个是 ReactJS 组件。最小的插件定义如下所示 12345678910111213141516import React from 'react';// You are obviously not limited to material-ui, but we really enjoy// the material-ui svg icons!import StarIcon from 'material-ui/svg-icons/toggle/star';// 引入要使用的ReactJS组件import InputTextField from './Component';export default &#123; Component: InputTextField, IconComponent: &lt;StarIcon /&gt;, name: 'example/content/input-text-field', version: '0.0.1', text: 'Input Text Field',&#125;; 一个简单的 ReactJS 组件可以是这样： 12345678910111213141516171819202122232425262728293031323334import React from 'react';// A callback function for the input fieldconst onInput = onChange =&gt; &#123; return e =&gt; &#123; // Dispatch the onChange action with the new value onChange(&#123; value: e.target.value, &#125;); &#125;;&#125;;const InputTextField = props =&gt; &#123; // 这里的state、readOnly和onChan是必须的 const &#123; state: &#123; value = '' &#125;, readOnly, onChange, &#125; = props; // 如果readOnly为false，说明编辑器处于可编辑状态 if (!readOnly) &#123; return ( &lt;div className="my-plugin"&gt; &lt;input type="text" onChange=&#123;onInput(onChange)&#125; value=&#123;value&#125; /&gt; &lt;/div&gt; ); &#125; // If we are not in edit mode, remove the input field return &lt;div className="my-plugin"&gt;&#123;value&#125;&lt;/div&gt;;&#125;;export default InputTextField; 当然，还有更多的设置和回调可用。欢迎查看关于此主题的 API 文档！ 最后，在 APP.js 中，启用刚写的内容插件。 123456import testInput from './component/testInput' // 引入刚刚写的内容插件...const plugins = &#123; content: [slate(), image, testInput], // 定义内容插件 layout: [parallax(&#123; defaultPlugin: slate() &#125;)] // 定义布局插件&#125; 来看看效果吧！ 在列表中，已经可以看到刚刚添加的内容插件 将内容插件拖到编辑器中，在编辑模式下能看到 input 输入框 注： 浏览器的控制台可能会报一个错误 Warning: Received true for a non-boolean attribute autoCorrect. 这个是因为 react 版本的问题，在 package.json 中从把”react”: “^16.2.0”换回”react”: “^15.4.0”, “react-dom”: “^15.4.0”, …后问题解决，具体原因还不知道。 参考:issues/494 编写一个布局插件布局插件有两个部分，一个插件定义和一个 ReactJS 组件。最小的布局插件定义如下所示 123456789101112131415161718import React from 'react';// You are obviously not limited to material-ui, but we really enjoy// the material-ui svg icons!import CropSquare from 'material-ui/svg-icons/image/crop-square';// 样式定义const BlackBorderPlugin = (&#123; children &#125;) =&gt; ( &lt;div style=&#123;&#123; border: '1px solid black', padding: '16px', height: '300px' &#125;&#125;&gt;&#123;children&#125;&lt;/div&gt;);export default &#123; Component: BlackBorderPlugin, IconComponent: &lt;CropSquare /&gt;, name: 'example/layout/black-border', version: '0.0.1', text: 'Black border',&#125;; 但是布局插件必须至少有一个子节点，否则布局插件将被自动删除，所以要加上默认的子节点。 修改 export 为： 123456789101112131415161718192021222324252627import _uuid from 'uuid'...export default (child) =&gt; &#123; var defaultPlugin = child.defaultPlugin; return &#123; Component: BlackBorderPlugin, IconComponent: &lt;CropSquare /&gt;, name: 'example/layout/black-border', version: '0.0.1', text: 'Black border', createInitialChildren: function createInitialChildren() &#123; return &#123; id: (0, _uuid.v4)(), rows: [&#123; id: (0, _uuid.v4)(), cells: [&#123; content: &#123; plugin: defaultPlugin, state: defaultPlugin.createInitialState() &#125;, id: (0, _uuid.v4)() &#125;] &#125;] &#125;; &#125; &#125;&#125; 其中 createInitialChildren 返回的对象格式不能随意修改，否则Editor可能无法正常识别，而导致错误 最后，在 APP.js 中，添加布局插件的地方传入一个默认的内容组件 123456import testLayout from './component/testLayout' // 引入刚刚写的布局插件...const plugins = &#123; content: [slate(), image, testInput], // 定义内容插件 layout: [parallax(&#123; defaultPlugin: slate() &#125;), testLayout(&#123;defaultPlugin: slate()&#125;)] // 定义布局插件&#125; 来看看效果吧！ 在列表中，已经可以看到刚刚添加的布局插件 将布局插件拖到编辑器中，在编辑模式下能看到样式为border: &#39;1px solid black&#39;, padding: &#39;16px&#39;, height: &#39;300px&#39;的布局，以及嵌套在其中的默认子组件（富文本内容插件），在移动模式下，将这个子组件删除，整个布局插件就会自动删除。 呈现 HTML该ory-editor-renderer软件包提供了一个轻量级的 HTML 渲染器模块，通过这个模块渲染出展示用的 html 页面。您可以将其用于服务器端渲染或客户端渲染 1234567891011121314151617import &#123; HTMLRenderer &#125; from 'ory-editor-renderer';const content = getEditorContent(id); // 获取编辑器的数据，这只是一个例子const state = &#123; /* ... */&#125;;const plugins = &#123; layout: [ /* ... */ ], // 布局插件 content: [ /* ... */ ], // 内容插件&#125;;const element = document.getElementById('editable');ReactDOM.render(&lt;HTMLRenderer state=&#123;content[0]&#125; plugins=&#123;plugins&#125; /&gt;, element); 保存和恢复编辑器内容使用onChange回调来获取编辑器 state 的副本，可以用来持久化数据（存到数据库或其他方式保存数据）。之后这个被持久化的 state 可以加载到编辑器中被再次编辑，或者被ory-editor-renderer包渲染成 HTML。 12345678910111213141516171819202122232425262728293031323334import React from 'react';import Editor, &#123; Editable, createEmptyState &#125; from 'ory-editor-core';import slate from 'ory-editor-plugins-slate'; // The rich text area pluginimport &#123; Trash, DisplayModeToggle, Toolbar &#125; from 'ory-editor-ui';const EditorPlugins = &#123; content: [slate()], layout: [ /* ... */ ],&#125;;function saveToDatabase(state) &#123; return fetch('/my/save/url', &#123; method: 'POST', body: state &#125;);&#125;class MyEditor extends React.Component &#123; componentWillMount() &#123; this.editorState = this.props.content || createEmptyState(); this.editor = new Editor(&#123; EditorPlugins, editables: [content] &#125;); &#125; render() &#123; return ( &lt;div className="my-editor"&gt; &lt;toolbar&gt; &lt;button onClick=&#123;() =&gt; saveToDatabase(this.editorState)&#125;&gt;Save&lt;/button&gt; &lt;/toolbar&gt; &lt;Editable editor=&#123;editor&#125; id=&#123;content.id&#125; onChange=&#123;state =&gt; (this.editorState = state)&#125; /&gt; &lt;Trash editor=&#123;editor&#125; /&gt; &lt;DisplayModeToggle editor=&#123;editor&#125; /&gt; &lt;Toolbar editor=&#123;editor&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 然后可以通过执行如下操作来获取状态： 12345678910111213141516171819202122232425262728import React from 'react'import &#123; HTMLRenderer &#125; from 'ory-editor-renderer'import &#123; createEmptyState &#125; from 'ory-editor-core'class MyEditorRenderer extends React.Component &#123; componentWillMount() &#123; this.plugins = &#123; //&#125;; this.setState(&#123; contents: createEmptyState() &#125;); fetch('/my/save/url').then((savedState) =&gt; &#123; this.setState(&#123; contents: savedState &#125;); &#125;) &#125; render() &#123; return ( &lt;div className="my-editor"&gt; &lt;HTMLRenderer state=&#123;this.state.contents&#125; plugins=&#123;EditorPlugins&#125; /&gt; &lt;/div&gt; ) &#125;&#125;const element = document.getElementById('editable')ReactDOM.render(( &lt;MyEditorRenderer /&gt;), element) 下面内容的作用还不知道，就先放出原文 Handling native drag eventsThe ORY Editor is capable of handling native drag and drop events. Native events include dragging of links, text, and images. Native drag support can be enabled by writing a NativePlugin and passing it during instantiation. In this example, we will use the default plugin, and take a look at how you can create your own later. 123456789import native from &apos;ory-editor-plugins-default-native&apos;const editor = new Editor(&#123; plugins: &#123; layout: [], content: [], native &#125;&#125;) If native is undefined or null, native dragging wil be disabled. This is the default setting. Writing a native plugin is like writing a content or layout plugin. The only difference is that our native plugin must be wrapped in a factory that receives three arguments - hover, monitor, and component. Hover is the cell or row that is currently being hovered. Monitor is the DropTargetMonitorcoming from react-dnd and component is the React component of the cell or row that is currently being hovered. In sum, an exemplary plugin looks like this: 123456789import React from &apos;react&apos;const Native = () =&gt; &lt;div&gt;native&lt;/div&gt;export default (hover, monitor, component) =&gt; (&#123; Component: Native, name: &apos;my-native-plugin&apos;, version: &apos;0.0.1&apos;&#125;) Because this plugin is wrapped in a factory, we are able to modify its behaviour based on the properties we receive. One such example would be to add the item’s data to the initial state for later use. 123456export default (hover, monitor, component) =&gt; (&#123; // ... createInitialState: () =&gt; (&#123; item: monitor.getItem() &#125;)&#125;) Per default, the editor assumes that dropping the native element creates a content cell. To change this behaviour, use the key type: 1234export default (hover, monitor, component) =&gt; (&#123; // ... type: &apos;layout&apos;&#125;) 插件基础包ory-editor-core这个包是 ORY Editor 的核心。它包含创建和修改布局的逻辑，并负责处理插件。 ory-editor-ui包含基于callemall / material-ui 的 的 UI React 组件 。虽然不是必须使用它们，但它们提供了一个简单的方法来开始使用 ORY Editor。 ory-editor-renderer包含 ORY Editor 的渲染组件，目前只支持 HTML 渲染，负责将数据输出为静态 HTML。 内容插件ory-editor-plugins-slate创建和修改富文本，并针对 ORY Editor 进行了优化 ory-editor-plugins-image通过 URL 添加图片，不支持上传。 ory-editor-plugins-video通过 URL 添加视频。 ory-editor-plugins-spacer创建一个空的固定高度的Cell 内容插件ory-editor-plugins-parallax-background添加一个视差背景图像作为背景]]></content>
      <tags>
        <tag>react</tag>
        <tag>可视化编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[满意度问卷调查项目总结]]></title>
    <url>%2F2017%2F11%2F27%2F%E6%BB%A1%E6%84%8F%E5%BA%A6%E9%97%AE%E5%8D%B7%E8%B0%83%E6%9F%A5%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[项目总体描述&emsp;&emsp;满意度调查项目总体需求比较简单，使用了 vue 的 vux 组件库，整体使用下来非常方便，虽然说本次需求中问卷的题目是固定的，但是为了未来的复用性考虑，还是将整个问卷作为可配置来开发，后来发现整个决定很大程度上减少了开发的时间。 需求&emsp;&emsp;项目 1.0 版本在 11 月 25 日正式上线，在本次项目中，我负责微信端的开发，页面包括： 登录界面，主要工作为按照设计制作页面，制作登录功能 问卷页面，主要功能为填写问卷和提交答案，问题类型分为四种： 单选 多选（其他选项上需要一个输入框输入详细原因） 打分 填空 &emsp;&emsp;其他功能： 跳转：选择某一选项跳转到某一道具体的题目上，若没配置，则默认下一题 显示控制：未被跳转到的题目保持折叠状态 必填控制：遇到选填题时自动显示下一题 结果页面，主要功能为按照设计制作页面，显示抽奖号 原型 关于技术&emsp;&emsp;这次项目使用 vue 框架，因为以前有使用过，所以总体上手比较快，vux 组件库简单易用，非常适合移动端开发。 遇到的问题一、题目列表设计&emsp;&emsp;需求总流程很简单，主要难点集中在如何设计一个可配置的问卷。 1. 总结构 2. 问卷数据的 json 结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546answer: [ &#123; questionId: &apos;&apos;, // 问题id optionsList: [], // 答案选项id（单选和多选） optionContent: &apos;&apos; // 保存其他选项的详细内容（多选） answerContent: &apos;&apos;, // 保存字符串（文字和打分） otherId: &apos;&apos; // 其他这个选项的id（多选） &#125;, ...]question: [ &#123; &quot;questionId&quot;: 4, // 问题id &quot;questionType&quot;: &quot;&quot;, // 问题类型（0:单选；1:多选 2:打分；3:填空） &quot;questionNo&quot;: 4, // 问题在问卷中的题号 &quot;questionName&quot;: &quot;&quot;, // 问题的标题 &quot;isRequired&quot;: &quot;1&quot;, // 问题是否为必选 &quot;remark&quot;: null, // 备注（文字题中用于placeholder） &quot;cateId&quot;: 1, // 问题主题id &quot;scheduleId&quot;: 0, // 问卷id &quot;optionsList&quot;: [ // 问题选项列表（单选和多选） &#123; &quot;optionId&quot;: 6, // 选项id &quot;questionId&quot;: 4, // 问题id &quot;optionContent&quot;: &quot;&quot;, // 选项内容 &quot;isOther&quot;: &quot;0&quot;, // 是否为其他项（多选） &quot;remark&quot;: null, // 备注 &quot;optionNo&quot;: 1, // 选项在问题中的编号 &quot;linkQuestionId&quot;: null // 选择后跳转到问题id &#125;, &#123; ... &#125; ... ], &quot;optionScore&quot;: &#123; // 打分题配置 &quot;optionScoreId&quot;: 30, // 分数选项id &quot;questionId&quot;: 78, // 问题id &quot;scoreMin&quot;: 1, // 最低分 &quot;scoreMax&quot;: 10, // 最高分 &quot;scoreLimit&quot;: 6, // 分界线 &quot;linkQuestionId&quot;: 11 // 大于分界线跳转到问题id &#125; &#125;, ...] &emsp;&emsp;通过分析需求，可以看出题目的跳转和选项相关，所以数据库中把控制跳转的的字段放在问题的选项中（optionsList 或 optionScore）。此外，保留了很多可配置的字段，为了后面题目发生修改时能快速调整。 3. 问卷生成 &emsp;&emsp;问卷是由 question 数组循环生成，在 question 组件中通过判断 questionType 生成不同的类型的题目，这样做的是为了把每个问题中公共的部分（保存答案，跳转事件，生成题目标题，控制显示等）放在 question 组件中处理。这样如果以后有新的题目类型，只需要在 question 组件中添加即可。 &emsp;&emsp;在题目修改答案的时候保持单向的数据流，这样页面中每个样式的变化都是有迹可循的，发生错误时不会无从下手，并且保证页面显示和内存中的值保存一致。为了方便后端的解析入库，不同类型题目的 answer 对象保存一致，这就需要在 question 组件中对 answer 对象进行拆解和组装。此外，question 还可以在回传 answer 对象的时候，附带下一题题目的下标，在 questionList 中进行跳转。 二、CSS 的作用域&emsp;&emsp;vue 项目一般使用单文件组件，组件中的 css 样式作用域以前一直是非常头疼的问题，之前常用的做法一般通过在外层 div 包一个 class 来控制作用域，但是这种做法会莫名地增加工作量，而且写到最后，复杂的 css 后代选择器很难辨别不说还影响性能，所以 vue 里通过“别名”的方式来控制作用域。 1. CSS 作用域&emsp;&emsp;当 &lt;style&gt; 标签有 scoped 属性时，它的 CSS 只作用于当前组件中的元素。这类似于 Shadow DOM 中的样式封装。它有一些注意事项，但不需要任何 polyfill。它通过使用 PostCSS 来实现以下转换： 123456789&lt;style scoped&gt;.example &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;example&quot;&gt;hi&lt;/div&gt;&lt;/template&gt; 转换结果： 123456789&lt;style&gt;.example[data-v-f3f3eg9] &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class=&quot;example&quot; data-v-f3f3eg9&gt;hi&lt;/div&gt;&lt;/template&gt; 2. CSS Modules&emsp;&emsp;CSS Modules 是一个用于模块化和组合 CSS 的流行系统。vue-loader 提供了与 CSS 模块的一流集成，可以作为模拟 CSS 作用域的替代方案。 &emsp;&emsp;使用&emsp;&emsp;Vue-loader 在 v9.8.0 之后加入了对 CSS Modules 的支持。我们只要在.vue 文件的&lt;style&gt;处加一个 module 就行 12345678&lt;style module&gt;.red &#123; color: red;&#125;.bold &#123; font-weight: bold;&#125;&lt;/style&gt; &emsp;&emsp;这将为 css-loader 打开 CSS Modules 模式，生成的 CSS 对象将为组件注入一个名叫 $style 的计算属性，你可以在你的模块中使用动态 class 绑定： 12345&lt;template&gt; &lt;p :class=&quot;$style.red&quot;&gt; This should be red &lt;/p&gt;&lt;/template&gt; &emsp;&emsp;转换结果： 123&lt;p class=&quot;_1VyoJ-uZOjlOxP7jWUy19_0&quot;&gt; This should be red&lt;/p&gt; &emsp;&emsp;支持语法&emsp;&emsp;由于它是一个计算属性，它也适用于 :class 的 object/array 语法： 12345678910&lt;template&gt; &lt;div&gt; &lt;p :class=&quot;&#123; [$style.red]: isRed &#125;&quot;&gt; Am I red? &lt;/p&gt; &lt;p :class=&quot;[$style.red, $style.bold]&quot;&gt; Red and bold &lt;/p&gt; &lt;/div&gt;&lt;/template&gt; &emsp;&emsp;你也可以在 JavaScript 访问它： 123456789&lt;script&gt;export default &#123; created () &#123; console.log(this.$style.red) // -&gt; &quot;_1VyoJ-uZOjlOxP7jWUy19_0&quot; // an identifier generated based on filename and className. &#125;&#125;&lt;/script&gt; &emsp;&emsp;配置&emsp;&emsp;默认的配置是&#39;[hash:base64]&#39;，即将 class 名转为 hash 值，可读性比较低，不方便调试开发，可以在 Webpack 中对 css-loader 进行配置。针对 vue，在 vue-loader 中配置 cssModules 属性里即可。 123456789loader: &apos;vue&apos;,options: &#123; cssModules: &#123; // 设置本地别名 localIdentName: &apos;[name]-[local]-[hash:base64:5]&apos;, // 开启驼峰式支持 camelCase: true &#125;&#125; &emsp;&emsp;配置后，刚刚的代码转换结果变为 1234&lt;!-- [组件名]-[class]-[hash] --&gt;&lt;p class=&quot;App-red-3cl75_0&quot;&gt; This should be red&lt;/p&gt; 3. 项目使用&emsp;&emsp;项目中很多情况下需要对第三方 UI 库中的组件样式做调整，如： 12345678910111213141516&lt;template&gt; &lt;div class="question"&gt; &lt;div class="weui-cells__title"&gt; test &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; .question &#123; &#125; .question .weui-cells__title &#123; &#125;&lt;/style&gt; &emsp;&emsp;test 所在的&lt;div&gt;是第三方生产，要修改 test 文字的样式 &emsp;&emsp;使用 scoped12345678910111213141516&lt;template&gt; &lt;div class=&quot;question&quot;&gt; &lt;div class=&quot;weui-cells__title&quot;&gt; test &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .question &#123; &#125; .question .weui-cells__title &#123; &#125;&lt;/style&gt; &emsp;&emsp;转换结果： 1234567891011121314&lt;div data-v-b8a14a32 class=&quot;question&quot;&gt; &lt;div class=&quot;weui-cells__title&quot;&gt; test &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .question[data-v-b8a14a32] &#123; &#125; .question .weui-cells__title[data-v-b8a14a32] &#123; &#125;&lt;/style&gt; &emsp;&emsp;使用这种方式，可能看到转化后的类名并不能匹配到对应的位置，我们期望的类名应该为 1.question[data-v-b8a14a32] .weui-cells__title &emsp;&emsp;所以如果要修改第三方的 ui 组件，最好使用 css modules &emsp;&emsp;使用 CSS Modules123456789101112131415&lt;template&gt; &lt;div :class=&quot;$style.question&quot;&gt; &lt;div class=&quot;weui-cells__title&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style module&gt; .question &#123; &#125; .question :global(.weui-cells__title） &#123; &#125;&lt;/style&gt; &emsp;&emsp;转换结果： 12345678910111213&lt;div class=&quot;questionList-question-MErG2_0&quot;&gt; &lt;div class=&quot;weui-cells__title&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .questionList-question-MErG2_0 &#123; &#125; .questionList-question-MErG2_0 .weui-cells__title&#123; &#125;&lt;/style&gt; &emsp;&emsp;在.vue 文件的&lt;style&gt;处加一个 module，默认将类名转化为局部变量，使用:global(...)来标记全局变量，通过这种方式可以很容易地覆盖原有 UI 组件样式。 参考： css 作用域 · vue-loader css Modules · vue-loader 在 Vue 工作流中使用 CSS Modules css-loader 文档 css-modules-demo 三、IE 兼容&emsp;&emsp;因为 IE 不支持 es6 语法，所以如果需要适配 IE 浏览器，需要做特殊的适配处理。vue 使用 webpack 构建项目，可以通过 babel-polyfill 把代码从 es6 转为 es5。 错误1[vuex] vuex requires a Promise polyfill in this browser. 解决办法1npm install --save-dev babel-polyfill 在 webpack.config.js 配置 12345module.exports = &#123; entry: &#123; app: [&apos;babel-polyfill&apos;,&apos;./src/main.js&apos;] &#125;,&#125;; 最后的一些想法&emsp;&emsp;这次项目使用的框架是 vue，相对于 react，vue 的整体结构化更加清晰一些，很容易写出比较标准的代码，整体的编程风格让人不由自主地超着低耦合的解决方案接近，当然其中也踩了不少的坑，一方面是语法之间的差别需要适应，另一方面就是在有些控件的事件触发顺序上与我想象中的差别很大，经常造成数据显示错误，虽然最后通过 dom 操作强行同步了值，但不是好的解决方案，本次项目中由于某些需求的特殊性，在项目的后期加了很多逻辑比较混乱的代码，如果后面还需要重新使用的话，还需要好好想想重构这些代码。另外题目的可配置性还不够完善，很多地方还是依据当前项目的要求写死，不够通用，这些都是可以改进的地方。]]></content>
      <tags>
        <tag>项目总结</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云选项目总结]]></title>
    <url>%2F2017%2F11%2F12%2F%E4%BA%91%E9%80%89%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[项目总体描述&emsp;&emsp;绿城云选是我进入公司的第一个项目，经历了项目从无到有的整个过程，也是第一次体验了前后台分离的开发方式。 一、1.0 版本&emsp;&emsp;项目 1.0 版本在 10 月 18 日在集团内部内测，我主要负责了以下几个模块： 后台 基础信息管理模块，包括客户信息管理和房源信息管理，功能上以增删改查为主。 抢房管理模块，除了查询功能外，根据不同的房源状态进行转保留、转不可售、转待售的操作，以及数据的 excel 导出。 资料录入及设置模块，对在线开盘的一些信息进行配置。 微信 楼盘信息页面，显示当前项目的楼盘信息。 房源列表页面的快速定位功能 点击返回时的逻辑控制 二、1.1 版本&emsp;&emsp;项目 1.1 版本预计在 11 月 17 日 UAT 完成并对外发布，我主要负责了以下几个模块： 后台 完成资格预选设置模块、客户信息管理中添加资格预选对应的功能 房源信息管理和客户信息管理中完成数据 excel 导入和模板下载 增加账号管理、项目管理、修改密码功能，控制不同用户访问模块的权限 制作多项目切换功能 修改在线开盘设置中的户型信息配置 部分页面的单次逻辑控制 微信 修改楼盘信息中的户型信息显示 增加收藏列表页面的置顶功能 关于技术&emsp;&emsp;因为是第一次使用 react，所以在开始项目前自学了两天，在了解 react 的基础语法和一些配套使用的库后，就开始尝试着做项目中比较简单的基础信息模块，之后再难度渐渐上升，在后面持续的工作学习中，我对于 react 的认知渐渐加深和也对前端的认知有了一些转变。 一、对于 react 数据流 &emsp;&emsp;react 中的大体工作逻辑与 vue 还是比较类似的，数据就像瀑布一样从父组件流向子组件(props)，且数据是不可变的(read only)，这种方式在发生问题时只要随着错误的数据”逆流而上”就很容易找到问题所在，相对于以前使用的 jQuery，这种便捷的排错方式无疑是更加科学高效的。 dom 操作 &emsp;&emsp;以前使用 jQuery 时是针对 dom 来编写代码，需要书写大量的 dom 获取、dom 赋值操作，业务代码混淆在其中，可读性很差。现在使用 react 是针对数据来编写代码，写代码时先将 dom 和数据的关系绑定好，只要修改数据，页面就能相应地变化，这个认知的转变对于前端来说是非常重要的，首先将人从繁琐的取值赋值操作中解放出来，专心于业务逻辑，其次大大提高了代码的可读性。 JSX &emsp;&emsp;JSX 是一种看起来像是 html 的 JavaScript 语法扩展。第一次使用时，会感觉语法有些奇怪，但是却意外地好用，尤其是需要条件渲染和列表渲染时 JSX 是非常好的选择。jQuery 生成列表时，往往使用 js 拼接 html 字符串，一旦列表中的内容复杂一点，拼接的难度会成倍上升，也非常容易出错，使用 JSX 可以直接用循环输出另一个 JSX 代码块，而 JSX 又看起来非常像是 HTML，减少了多层嵌套时标签出错发生的可能，整体的编码效率和可读性大大提升。 二、对于前端&emsp;&emsp;前后分离后，前端的职责发生了巨大的变化，工作内容不再是之前那样单纯地向 dom 绑定下数据，修改样式。前端现在有些像以前的后台，也有完整的 MVC 结构，单向数据流清晰可见，此外还负责整个项目的页面逻辑跳转等，与之相对的各种新技术层出不穷，作为一个新入门不久的前端工程师，必须要要有意识地打好基础，紧跟时代发展趋势，前端最快的学习方式就是实践，尤其是不管是 html、css、js 这些基础还是比较新的 es6，都需要在实践中仔细体会它们语句后的效果。 遇到的问题一、后台时间设置组件&emsp;&emsp;云选 1.0 后台中，如何做一个校验正确的时间设置组件这个问题困扰了我挺久： 时间要按照在线体验–&gt;公测选房按–&gt;正式选房的顺序从小到大 倒计时可以没有，但是如果有倒计时，本次当前倒计时的开始时间必须在上次活动之后 在线体验和公测选房为选填，正式选房必填 方案一：&emsp;&emsp;通过上面的条件可以发现，每个时间选择框的校验规则相似却都不太一样，我想不到什么好的办法，就只好一个个时间分开校验，每个时间都写了不同的校验规则，比如正式选房的开始时间，需要判断以下条件：&emsp;&emsp;可以看到，光是一个时间的判断流程就非常繁琐，而且不能保证面面俱到，多个地方的判断条件都是写死的，没有通用性而且很难修改。 方案二：&emsp;&emsp;在尝试了很久之后，终于决定放弃之前的方案，后来在仔细观察后，找到了一些规律，以开始时间、结束时间、倒计时三个组件合在一起制作一个时间设置组件，并找到一个比较通用且准确的时间校验方案。 先设置在线体验–&gt;公测选房按–&gt;正式选房的顺序 12const allTimeName = [&apos;preStartDate&apos;,&apos;preEndDate&apos;,&apos;expStartDate&apos;, &apos;expEndDate&apos;, &apos;testStartDate&apos;, &apos;testEndDate&apos;, &apos;openStartDate&apos;, &apos;openEndDate&apos;] const allTime = [preStartDate, preEndDate, expStartDate, expEndDate, testStartDate, testEndDate, openStartDate, openEndDate] 将名字和值传入组件中 123456789101112131415161718192021222324252627282930313233343536373839// 时间组件属性 const timeProps = &#123; timeCardProps, allTime, allTimeName, allCountDown, getFieldDecorator, validateFields, getFieldValue, &#125; return ( &lt;Card title=&quot;时间安排&quot; bordered=&#123;false&#125; style=&#123;&#123;marginTop: &apos;24px&apos;&#125;&#125;&gt; &lt;TimeSettingItem &#123;...timeProps&#125; label = &#123;&apos;在线体验&apos;&#125; startTimeName = &#123;&apos;expStartDate&apos;&#125; endTimeName = &#123;&apos;expEndDate&apos;&#125; hourName = &#123;&apos;expHour&apos;&#125; isRequired = &#123;false&#125; /&gt; &lt;TimeSettingItem &#123;...timeProps&#125; label = &#123;&apos;公测选房&apos;&#125; startTimeName = &#123;&apos;testStartDate&apos;&#125; endTimeName = &#123;&apos;testEndDate&apos;&#125; hourName = &#123;&apos;testHour&apos;&#125; isRequired = &#123;false&#125; /&gt; &lt;TimeSettingItem &#123;...timeProps&#125; label = &#123;&apos;正式选房&apos;&#125; startTimeName = &#123;&apos;openStartDate&apos;&#125; endTimeName = &#123;&apos;openEndDate&apos;&#125; hourName = &#123;&apos;openHour&apos;&#125; isRequired = &#123;true&#125; /&gt; &lt;/Card&gt; ) 根据名字确定时间在数组中的下标，可以用下标来获取对应的数据值和获取前一个时间和后一个时间，使用前一个时间和后一个时间来进行数据校验 12const startDateIndex = allTimeName.indexOf(startTimeName)const endDateIndex = allTimeName.indexOf(endTimeName) 其他小问题&emsp;&emsp;当设置开始和结束时间后，需要触发倒计时的校验，判断当前活动倒计时开始时间是否在上个活动结束之后，所以需要对开始和结束时间的 onChange 事件做处理，这里使用 validateFields()函数来触发倒计时的校验，后面的{ force: true }如果不加，会导致数据只校验一次，再次修改时间不再触发倒计时校验，此外使用 setTimeout()方法是因为，控件的赋值操作在 onChange 事件之后，使用异步操作来确保倒计时的校验在时间赋值之后。 12345const onDateChange = (otherTimeIndex, e) =&gt; &#123; let validateValue = [&apos;testHour&apos;, &apos;expHour&apos;, &apos;openHour&apos;] validateValue.push(allTimeName[otherTimeIndex]) setTimeout(() =&gt; &#123;validateFields(validateValue, &#123; force: true &#125;)&#125;, 10)&#125; &emsp;&emsp;此外校验数据时，注意取值要使用 getFieldValue()，不然会导致取值错误 二、微信倒计时组件&emsp;&emsp;微信上的楼盘信息页面需要一个倒计时组件，在后台配置倒计时的情况下，当时间到达倒计时范围内时，显示倒计时。这个难点主要在于当微信进入后台或进行锁屏等操作返回当前页面时，要保证倒计时时间的准确性。主要实现方式如下： 三、移动端返回按钮控制&emsp;&emsp;js 并没有返回事件，只有跳转事件，而且无法阻止它发生跳转，如果要做到返回按钮失效，需要用新页面的 URL 替换当前的历史纪录，这样浏览历史记录中就只有一个页面，后退按钮永远失效。 1. 在挂载时添加1234567//1.挂载的时候给popstate事件增加监听器,//2.将url替换为http://ip:host/xxx#,每次点击返回时返回到http://ip:host/xxx componentDidMount() &#123; window.addEventListener(&apos;popstate&apos;, this.back) window.history.pushState(&apos;openInformation&apos;, null, &apos;#&apos;); //在IE中必须得有这两行 window.history.forward(1); &#125; 2. 在卸载时添加1234//候给popstate事件去除监听器 componentWillUnmount () &#123; window.removeEventListener(&apos;popstate&apos;, this.back) &#125; 3. 根据需求写监听事件1234567// 若在事件中使用 // window.history.pushState(&apos;openInformation&apos;, null, &apos;#&apos;); // window.history.forward(1); // 则可以页面一直保持在本页面，效果类似于返回按钮失效 back = () =&gt; &#123; ... &#125; 四、滚动穿透问题试了 3 种方法 CSS 样式控制：123456.modal-open &#123; &amp;, body &#123; overflow: hidden; height: 100%; &#125;&#125; 页面弹出层上将 .modal-open 添加到 html 上，禁用 html 和 body 的滚动条但是这个方案有两个缺点： 由于 html 和 body 的滚动条都被禁用，弹出层后页面的滚动位置会丢失，需要用 js 来还原 页面的背景还是能够有滚的动的效果 js 事件控制123modal.addEventListener(&apos;touchmove&apos;, function(e) &#123; e.preventDefault();&#125;, false); 这样用 js 阻止滚动后看起来效果不错了，但是也有一个缺点： 弹出层里不能有其它需要滚动的内容（如大段文字需要固定高度，显示滚动条也会被阻止，需求中由于要显示活动协议，需要在弹窗中滚动，这种方式不能用） fixed + js1234body.modal-open &#123; position: fixed; width: 100%;&#125; 如果只是上面的 css，滚动条的位置同样会丢失所以如果需要保持滚动条的位置需要用 js 保存滚动条位置关闭的时候还原滚动位置 1234567891011121314151617181920/** * ModalHelper helpers resolve the modal scrolling issue on mobile devices * https://github.com/twbs/bootstrap/issues/15852 * requires document.scrollingElement polyfill https://github.com/yangg/scrolling-element */var ModalHelper = (function(bodyCls) &#123; var scrollTop; return &#123; afterOpen: function() &#123; scrollTop = document.scrollingElement.scrollTop; document.body.classList.add(bodyCls); document.body.style.top = -scrollTop + &apos;px&apos;; &#125;, beforeClose: function() &#123; document.body.classList.remove(bodyCls); // scrollTop lost after set position:fixed, restore it back. document.scrollingElement.scrollTop = scrollTop; &#125; &#125;;&#125;)(&apos;modal-open&apos;); 示例 最后的一些想法&emsp;&emsp;云选项目最大的难点在于抢房时的体验，当前房源列表使用轮询的方式保持数据同步，这种方式存在一定的延迟，在体验上没有 WebSocket 那样完全同步，如果后面有机会可以针对这个做出修改，另外微信端还有很多地方可以优化，如图片懒加载、页面的 js 过大，删除没用的依赖等。&emsp;&emsp;总的来说，整个项目制作下来还算顺利，虽然中间在某些地方稍微走了弯路，但是还好能及时发现改正，完成这个项目对于我的意义重大，至此我的前端算是入门了，非常感谢彭飞和吴松在项目进行中对我技术上的帮助，也非常感谢项目组中的其他成员，良好的沟通和愉悦的工作环境让整个项目能有条不紊地进行。在后续的工作里仍需继续努力，提升自己。]]></content>
      <tags>
        <tag>react</tag>
        <tag>项目总结</tag>
      </tags>
  </entry>
</search>
